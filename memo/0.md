# ObservedProperties

　値を代入したら任意の処理を実行するオブジェクトを生成する。デザインパターンの一つObserverを利用している。モデル駆動とも言う。

* Type		型判定
* Valid		値の妥当性確認（Range,Options）
* Assign	値が代入された時（型や妥当性は不問）
* Change	値が変更された時（型が正しく、値が妥当である。Updateする直前）
* setup		値を一括設定しつつUpdateは一度だけ行う（複数の値を個別に設定するとその数だけUpdateが実行されてしまい負荷が高いから一度だけ行う）
* update	関連する値やHTML要素などを再計算する

```javascript
const o = new Obs({
  name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  age:{type:Number, value:12, valid:Obs.Valid.Range(0, 100)},
  male:{type:Boolean, value:false},
  _:{
    message:{type:String, value:''},
  }},
  (o)=>{
    o._.message = `私の名前は ${o.name}、${o.age} 歳、${o.male ? '男' : '女'}です。`;
  }
);
o.name = 'X';
o.age = 34;
o.male = true;
o.notHas // TypeError: 存在しないプロパティ名です
o.name = 12; // TypeError: 型が違います。
o.setup({name:'Y', age:56}); // 複数のプロパティを好きな分だけ好きなように変更する。更新処理は一度だけ実行される。
```
```javascript
const o = new Obs({...;
class C {}
defineDescriptor(ins, o);
const c = new C();
c.name = 'X';
o.notHas // TypeError: 存在しないプロパティ名です
```
```javascript
const o = new Obs({
  name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  age:{type:Number, value:12, valid:Obs.Valid.Range(0, 100)},
  male:{type:Boolean, value:false},
  name:{type:String, value:'v', valid:Obs.Valid.Option('山田', '鈴木', '田中')}, 
  name:{type:String, value:'v', valid:Obs.Valid.Unique('山田', '鈴木', '田中')}, 
  name:{type:Uint8Array, args:[128]}, 
  name:{value:new Uint8Array(128)}, 
  name: new Uint8Array(128), 
  name: new Obs({
    name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  }),
```
変数と定数では別のコンストラクタを用意したほうがいいかもしれない。`mutable:true`を全プロパティにセットするの面倒すぎる。
```javascript
const o = new Obs({
  name:{
      type:String, 
      value:'v', 
      nullable:false, undefinedable:false, nanable:false, infinitable:false, mutable:false,
      valid:/[a-z_][0-9a-z_]/i,
  }, 
```
```javascript
const o = new Obs({
  name: '山田',
  age: 12,
  male: false,
  // オブジェクト型はすべて参照に対してのみSetterで型チェック等を行う。オブジェクトが持つ子要素に対しては対象外
  url: new URL('https://www.google.co.jp/'),
  pattern: new RegExp('\n{2,}', 'g'),
  ary: [],
  obj: {}, // 
  sub: new Obs({...}),
});
```

　型は初期値によって推測可能なはず。但し`12`はNumber型であり整数も少数も無限数も非安全な2^53-1より大きい整数も取れてしまう。困る。

　クラス定義でもGetter/Setterに対して同じことをしたい。

```javascript
class MyObsProp extends Obs {
    constructor() {
        super({
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
        });
    }
}
```

　でもそれだけじゃ思い通りに制御できない。値の参照・代入・型妥当性チェックを自在に呼び出したい。

```javascript
class MyObsProp extends Obs {
    constructor() {
        super({
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
}
```
```javascript
const 変数 = Obs.var({...}); // mutable:true がデフォルト
const 定数 = Obs.fix({...}); // mutable:false がデフォルト
const props = new Obs.Cls({}, {...}, (o, c)=>{}) // 第一引数に任意オブジェクトを渡すと、そのオブジェクトに対してgetter/setterを作る
class MyObsProp extends Obs.Cls { // 第一引数にインスタンス変数thisを渡すと、自動的にgetter/setterを作ってくれる
    constructor() {
        super(this, {
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
    
}
```
```javascript
window.oo = ObservedObject;
window.ooo = ObservedObjectOwner;
```
```javascript
const 変数 = oo.var({...}); // mutable:true がデフォルト
const 定数 = oo.fix({...}); // mutable:false がデフォルト
const props = new oo.Cls({}, {...}, (o, c)=>{}) // 第一引数に任意オブジェクトを渡すと、そのオブジェクトに対してgetter/setterを作る
class MyObsProp extends oo.Cls { // 第一引数にインスタンス変数thisを渡すと、自動的にgetter/setterを作ってくれる
    constructor() {
        super(this, {
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
    
}
```

* 除外
	* Symbol
	* undefined
* 条件付き許容
	* null
* Boolean
* Number(NaN,±Infinityも含む)
	* Finite
		* Integer(SafeInteger(-2^53-1〜+2^53-1))
		* Float
* BigInt
* Function（AsyncFunction/GeneratorFunction/AysncGeneratorFunction/アロー関数/Asyncアロー関数）
* String
* 欲しいけど無い
	* ID（UUIDv4,v7/ULID）
	* DateTime
		* Date
		* Time
		* TimeSpan
		* DateSpan
		* DateTimeSpan
	* Color（CSS(red, #fff, #ffffff, #ffffffff)）
	* URL
const obs = ObservedValues({
  name: {nullable:false, undefinedable:false, nanable:false, inifitable:false, mutable:false, observable},
});


# プリミティブ型

　Number型を派生させ、Float, Intの二つのプリミティブ型を作りたい。

* Float: Number型だが、`NaN`,`Infinity`,`-Infinity`は代入できない(有限数Finite)
* Int: Number型だが、`Number.isSafeInteger()`な値しか代入できない

```javascript
Number
    Float
        Rate        0〜1
        Percent     0〜100
        Fraction    1/2, -2/9 (1/0 ゼロ除算不能。整数のみ代入可)
    Int             -2^53-1〜+2^53-1迄(2^52. 1〜52bitの符号付き迄)
    Ratio           1:1.414 (3:2:1等3つ以上にも対応したい。各値はNumber/Float/Int型のいずれか) でもこれプリミティブ型とは違う？　対象外にすべきか。
```
```javascript
Obs.Type.Int(123);
Int(123);
```
```javascript
const i = new Obs.Type.Int(123);
const i = new Int(123);
i.valueOf(); // プリミティブ値を返却する

const i = new Int(123, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
});
// 以下のようにインスタンスから参照したい要素もあるため、valueOf()だけでなくインスタンス自体も参照できるようにしたい。
i.unsafed
i.unsigned
i.bit
i.min
i.max
const o = Obs.var({age:Int(12, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
})})
o.age // ここで返すべきはIntインスタンスか、Int.valueOf()で返すプリミティブ値か。
o.age = 24; // ここでセットすべきはIntインスタンスか、Int.valueOf()で返すプリミティブ値か。
// もちろんプリミティブ型で入出力したい。でもObs内部ではInt.valid(value)を呼び出して値チェックする必要がある。
// だからObs内部ではIntインスタンスを保持している必要がある。
// この内部IntインスタンスはProxyインスタンスやsetコールバック関数内からも参照する必要がある。setupコールバック関数の引数では参照する必要はないはずだが、参照できれば便利
// o.someName
// o.setup({})
// o.$.message           // updateコールバック関数で計算し代入された値を参照する
// o._.primitiveSomeName // Intインスタンスなどプリミティブ型のインスタンス参照を返す。代入不可。
// o._isProxy            // Proxyであることを意味する真偽値を返す。
```
```javascript
Obs.Type.Integer(123);
Obs.Type.Int(123);
Obs.Type.I(123);
Obs.T.Int(123);
Obs.T.I(123, {
oo.T.I(123, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
});
```

```javascript
const o = Obs.var({age:0}); // {value:0}を省略した場合。Number型になるべきだが、NaN,+-Infinityは除外したい
```
```javascript
// JavaScriptデフォルトのNumber型はこれで再現できる
Obs.T.N(123, {
  naned: true,
  infinited: true,
})
```
```javascript
const o = Obs.var({age:Obs.T.N(123, {
  naned: true,
  infinited: true,
})};
```

js Numberのようにnewの有無で関数とコンストラクタを実行し分ける方法

new.targetの値をチェックすることで、new演算子の有無を判定し、処理を分けることができる。

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/new.target

```javascript
function CustomNumber(value) {
  // new.target が存在するか（new演算子で呼ばれたか）を判定する
  if (new.target) {
    console.log("コンストラクタとして実行されました");
    this.value = Number(value);
    // new 演算子使用時は自動的に新しいオブジェクトが返される
  } else {
    console.log("関数として実行されました");
    // 関数として実行された場合は、明示的に新しいインスタンスを生成して返す
    return new CustomNumber(value);
  }
}

// コンストラクタとして呼び出す
const obj1 = new CustomNumber(10); // 出力: コンストラクタとして実行されました
console.log(typeof obj1, obj1.value); // object 10

// 関数として呼び出す
const obj2 = CustomNumber(20); // 出力: 関数として実行されました -> コンストラクタとして実行されました
console.log(typeof obj2, obj2.value); // object 20
```

でも`Number`で参照したら関数であり、`v instanceof Number`はできない。

js Numberクラスを継承したクラスのコンストラクタ内でnewの有無により関数とコンストラクタを実行し分ける方法
