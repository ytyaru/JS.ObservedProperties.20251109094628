# ObservedProperties

　値を代入したら任意の処理を実行するオブジェクトを生成する。デザインパターンの一つObserverを利用している。モデル駆動とも言う。

* Type		型判定
* Valid		値の妥当性確認（Range,Options）
* Assign	値が代入された時（型や妥当性は不問）
* Change	値が変更された時（型が正しく、値が妥当である。Updateする直前）
* setup		値を一括設定しつつUpdateは一度だけ行う（複数の値を個別に設定するとその数だけUpdateが実行されてしまい負荷が高いから一度だけ行う）
* update	関連する値やHTML要素などを再計算する

```javascript
const o = new Obs({
  name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  age:{type:Number, value:12, valid:Obs.Valid.Range(0, 100)},
  male:{type:Boolean, value:false},
  _:{
    message:{type:String, value:''},
  }},
  (o)=>{
    o._.message = `私の名前は ${o.name}、${o.age} 歳、${o.male ? '男' : '女'}です。`;
  }
);
o.name = 'X';
o.age = 34;
o.male = true;
o.notHas // TypeError: 存在しないプロパティ名です
o.name = 12; // TypeError: 型が違います。
o.setup({name:'Y', age:56}); // 複数のプロパティを好きな分だけ好きなように変更する。更新処理は一度だけ実行される。
```
```javascript
const o = new Obs({...;
class C {}
defineDescriptor(ins, o);
const c = new C();
c.name = 'X';
o.notHas // TypeError: 存在しないプロパティ名です
```
```javascript
const o = new Obs({
  name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  age:{type:Number, value:12, valid:Obs.Valid.Range(0, 100)},
  male:{type:Boolean, value:false},
  name:{type:String, value:'v', valid:Obs.Valid.Option('山田', '鈴木', '田中')}, 
  name:{type:String, value:'v', valid:Obs.Valid.Unique('山田', '鈴木', '田中')}, 
  name:{type:Uint8Array, args:[128]}, 
  name:{value:new Uint8Array(128)}, 
  name: new Uint8Array(128), 
  name: new Obs({
    name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  }),
```
変数と定数では別のコンストラクタを用意したほうがいいかもしれない。`mutable:true`を全プロパティにセットするの面倒すぎる。
```javascript
const o = new Obs({
  name:{
      type:String, 
      value:'v', 
      nullable:false, undefinedable:false, nanable:false, infinitable:false, mutable:false,
      valid:/[a-z_][0-9a-z_]/i,
  }, 
```
```javascript
const o = new Obs({
  name: '山田',
  age: 12,
  male: false,
  // オブジェクト型はすべて参照に対してのみSetterで型チェック等を行う。オブジェクトが持つ子要素に対しては対象外
  url: new URL('https://www.google.co.jp/'),
  pattern: new RegExp('\n{2,}', 'g'),
  ary: [],
  obj: {}, // 
  sub: new Obs({...}),
});
```

　型は初期値によって推測可能なはず。但し`12`はNumber型であり整数も少数も無限数も非安全な2^53-1より大きい整数も取れてしまう。困る。

　クラス定義でもGetter/Setterに対して同じことをしたい。

```javascript
class MyObsProp extends Obs {
    constructor() {
        super({
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
        });
    }
}
```

　でもそれだけじゃ思い通りに制御できない。値の参照・代入・型妥当性チェックを自在に呼び出したい。

```javascript
class MyObsProp extends Obs {
    constructor() {
        super({
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
}
```
```javascript
const 変数 = Obs.var({...}); // mutable:true がデフォルト
const 定数 = Obs.fix({...}); // mutable:false がデフォルト
const props = new Obs.Cls({}, {...}, (o, c)=>{}) // 第一引数に任意オブジェクトを渡すと、そのオブジェクトに対してgetter/setterを作る
class MyObsProp extends Obs.Cls { // 第一引数にインスタンス変数thisを渡すと、自動的にgetter/setterを作ってくれる
    constructor() {
        super(this, {
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
    
}
```
```javascript
window.oo = ObservedObject;
window.ooo = ObservedObjectOwner;
```
```javascript
const 変数 = oo.var({...}); // mutable:true がデフォルト
const 定数 = oo.fix({...}); // mutable:false がデフォルト
const props = new oo.Cls({}, {...}, (o, c)=>{}) // 第一引数に任意オブジェクトを渡すと、そのオブジェクトに対してgetter/setterを作る
class MyObsProp extends oo.Cls { // 第一引数にインスタンス変数thisを渡すと、自動的にgetter/setterを作ってくれる
    constructor() {
        super(this, {
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
    
}
```

* 除外
	* Symbol
	* undefined
* 条件付き許容
	* null
* Boolean
* Number(NaN,±Infinityも含む)
	* Finite
		* Integer(SafeInteger(-2^53-1〜+2^53-1))
		* Float
* BigInt
* Function（AsyncFunction/GeneratorFunction/AysncGeneratorFunction/アロー関数/Asyncアロー関数）
* String
* 欲しいけど無い
	* ID（UUIDv4,v7/ULID）
	* DateTime
		* Date
		* Time
		* TimeSpan
		* DateSpan
		* DateTimeSpan
	* Color（CSS(red, #fff, #ffffff, #ffffffff)）
	* URL
const obs = ObservedValues({
  name: {nullable:false, undefinedable:false, nanable:false, inifitable:false, mutable:false, observable},
});


# プリミティブ型

　JavaScriptは数をNumber型で扱うが、これは64bitメモリであり、かつIEEE754の倍精度浮動小数点数で実装されている。このため十進数表示において、整数は15桁まで、少数は17桁までは正確に表現できるが、それ以上の桁になると正確に表現できず、比較式も不正確な結果を返してしまう。しかもそれを正常とし、エラーを発生させない。

　それでは困る。必ず正確に表せる範囲内のみ扱いたい。しかし実際には`0.000000000000000000001`のように17桁を超えた少数の入力をしてもエラーにできない。もしこれを正確にするなら、`Number.toFixed(15+1)`の文字列比較する。但し、16桁目は四捨五入されるので、16桁目は削除し、正確に表せる15桁までの数で比較する。但し少数比較は等号`===`では誤差があるため比較できない。よって誤差があってもイコールとみなす関数を用意する。

```javascript
nearlyEqual(x, y) {// 等号===の代替。JSのNumber型は64bit浮動少数点数であり比較等号===では完全一致確認できない（console.assert(0.3===0.1+0.2）でエラーになる）これをいくらか解決する。但し15桁の少数まで。
    if (parseInt(x) !== parseInt(y)) {return false}
    const T = parseInt(Math.abs(x + y));
    const tolerance = T < 1 ? Number.EPSILON : Number.EPSILON * T;
    return Math.abs(x - y) < tolerance;
}

// https://qiita.com/murasuke/items/0fb6a6f1bf4c03266720
// 浮動少数で誤差が出ることは避けられない。たとえ桁数を1桁にしても誤差が出てしまう。`(1.15).toFixed(1);`で`1.2`を返して欲しいのに`1.1`を返す等。
// 0.1+0.2=0.30000000000000004(17桁目で狂っている)
// 0.1+0.3=0.4 (なぜかピッタリ)
// 0.1+0.7=0.7999999999999999 (16桁目で途切れている。そもそも0.8未満)
// (0.1+0.7).toFixed(16)=0.7999999999999999 (16桁目で途切れている。そもそも0.8未満)
// (0.1+0.7).toFixed(15)=0.800000000000000 (なぜか15桁にすると0.8になる)
// たぶん桁数は1〜5など少ないほど精度が高まると思われる
// あとはNumber((0.1+0.7).toFixed(15))とすれば数になる。
roundedFloat(v,fig) {return Number(v.toFixed(fig ?? 17))}
roundedFloat(v,fig) {// 少数を16桁までで丸めた値を返す（17桁はIEEE754倍精度少数点数において誤差のない正確な値を示せる最大桁数である。でも0.1+0.2=0.30000000000000004(17桁目で狂っている)になったので16桁までとする）
  const s = v.toFixed(fig ?? 17);
  const S = s.split('.');
  if (1===S.length) {return v}
  const [i,f] = [S[0], S[1].slice(0,-1)]; // 整数部、少数部
  return Number(i+'.'+f);
  const F = 
  S[1]
  const F = 15 < f.length ? f.slice(0, 15) : f;
  // 小数点以下が0000000等ゼロだけで構成される場合や、00010000など途中から末尾までゼロが続く場合は、そのゼロを削除する
}
```

js で正確に浮動小数点数を計算する方法 は次の二通りある。

* 整数に変換してから計算するか
* 専用のライブラリを使用する

```javascript
function roundedFloat(v, fig=0) {
    const D = Math.pow(10, fig);
    const d = Math.trunc(v * D);
    return d / D;
}
```
```javascript
// fig は 少数部分の桁数。JSのNumberは整数15桁,少数17桁まで正確に表せるが、実際少数は様々な場面で誤差を生じさせるため整数化させる必要がある
// つまり少数部は整数化するため15桁が上限になる。しかも元々整数部であった数と共用するため、少数桁を多くするほど整数桁は少なくなる。
// 999999999999999や99999.9999999999や9999999999.99999までしか使えない。
//class RoundedFloat extends Float {
//    constructor(value, unsafed, unsigned, fig, min, max) {
//class DecimalFloat {
//class DecimalFinite {
//class DecimalNumber {
class DecimalFinite {// 10進数における整数と少数を合わせて15桁までの有限数
    constructor(value, fig, unsigned, min, max) {
        super(value, false, unsigned, min, max);
        this._.fig = {i:15-fig整数部の桁数, f:f少数部の桁数}
        this._.pad = {i:{char:'0',fig:'max/min/任意値'}, f:{char:'0',fig:'max/min/任意値'}} // 文字列表現するときの桁数と埋める字
        this._.I = 整数部; Number型としての整数
        this._.F = 少数部;  Number型としての整数
        this._.S = 文字列型としての表現;
        this._.N = Number型としての実数;
        this.roundedFloat(value, fig);
    }
    roundedFloat(v, fig=0) {// v:Number型実数
        const D = Math.pow(10, fig);
        const I = Math.trunc(v);
        const d = Math.trunc(v * D);
        this._.I = I;
        this._.F = parseInt(d.slice(I.toString().length));
        this._.S = `${this._.I}.${this._.F}`; // 整数部, 少数部それぞれに対してのゼロ埋めやスペース埋めをどうするか
        this._.N = parseFloat(this._.S); // d / D
    }
    valueOf() {return this._.N}
    get step() {return Number(Math.pow(0.1, this._.fig).toFixed(this._.fig));}
    // 四則演算(+:add, -:sub, *:mul, /:div), %:sur, **:pow        剰余:surplus
    add(v){}
    sub(v){}
    mul(v){}
    div(v){}
    sur(v){}
    pow(v){}
    // 自身の値と引数を演算した結果の新しいDecimalFloatインスタンスを返す（自身のインスタンス値はそのまま変更せず）
    toAdd(v) {}
    toSub(v) {}
    toMul(v) {}
    toDiv(v) {}
    toSur(v) {}
    toPow(v) {}
    // 演算した結果を引数にセットする（自身のインスタンス値はそのまま変更せず）引数がプリミティブ型かDecimalFloat型であるべきだし、それによって誤差が生じうる。
    addTo(){}
    subTo(){}
    mulTo(){}
    divTo(){}
    surTo(){}
    powTo(){}
}
class FazzyFloat {}// JavaScript標準のNumber型で、かつNaN,Infinityを除外した数
```

```
十進数15桁で整数のみなら最大1000兆-1。
999999999999999
999,999,999,999,999 K,M,G,T,E
999兆9999億9999万9999

2^32 = 4294967296 42億
2^49 = 562949950000000(5.6294995e+14) 562兆
十進数15桁はこの間
       999999999999999
2^49までなら表現できる。但し少数が0桁の場合。
十進数15桁はこの間
2^50 = 1125899900000000(1.1258999e+15) 1125兆
2^64 = 18446744000000000000(1.8446744e+19)
```
```
十進数整数12桁少数3桁計15桁で整数のみなら最大1兆-1。
-999999999999.999〜+999999999999.999
```

　やはり元となるNumber型で`0.1+0.7`すると`7.99999`になってしまうのが問題だ。これを根本解決することはできない。よって少数でなく整数を基本とすべきか。

　型を省略してNumber型がセットされた時、かつNumber.isSafeInteger()が真なら、今後もSafedIntegerを基本としたい。

```javascript
const o = new Obs({age:0});
```

　誤差が生じることを承知の上で浮動小数点数を使いたい時は以下のようにする。

```javascript
const o = new Obs({weight:{value:Float(62.1)}}); // Float
const o = new Obs({weight:{value:Float(62.0)}}); // Float
const o = new Obs({weight:{value:Float(62)}});   // Float
const o = new Obs({weight:{value:62.1}});        // Float判定
const o = new Obs({weight:{value:62.0}});        // Int判定
const o = new Obs({weight:{value:62}});          // Int判定
```

　型指定を省略するとInt判定されてしまう場合があるため区別できず危険。

```javascript
const o = new Obs({weight:{value:62.1}});        // Float判定にすべき？　それとも例外発生または警告ログ出力させるべき？
const o = new Obs({weight:{value:62.0}});        // Int判定
const o = new Obs({weight:{value:62}});          // Int判定
```




　Number型を派生させ、Float, Intの二つのプリミティブ型を作りたい。

* Float: Number型だが、`NaN`,`Infinity`,`-Infinity`は代入できない(有限数Finite)
* Int: Number型だが、`Number.isSafeInteger()`な値しか代入できない
    * AllInt: FasyInt/Intの両方を生成できる`new AllInt(value, unsafed, unsigned, bit, min, max)`
    * FussyInt: unsafed=trueな整数のみ生成できる`new FasyInt(value, unsigned, bit, min, max)`
    * Int: unsafed=falseな整数のみ生成できる`new Int(value, unsigned, bit, min, max)`
        * Odd: 奇数のみ生成できる
        * Even: 偶数のみ生成できる
        * Pow: xのy乗のみ生成できる`new Pow(2)` 2の0〜n(正数)乗のみセット可能
        * これら数列はValidatorで行うべきか。個別の型にしていたらキリがない。固定値でなく固定式でもなく任意式で自由に実装できるようにすべき。

```javascript
Number
    Float
        Rate        0〜1
        Percent     0〜100
        Fraction    1/2, -2/9 (1/0 ゼロ除算不能。整数のみ代入可)
    Int             -2^53-1〜+2^53-1迄(2^52. 1〜52bitの符号付き迄)
    Ratio           1:1.414 (3:2:1等3つ以上にも対応したい。各値はNumber/Float/Int型のいずれか) でもこれプリミティブ型とは違う？　対象外にすべきか。
```
```javascript
Obs.Type.Int(123);
Int(123);
```
```javascript
const i = new Obs.Type.Int(123);
const i = new Int(123);
i.valueOf(); // プリミティブ値を返却する

const i = new Int(123, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
});
// 以下のようにインスタンスから参照したい要素もあるため、valueOf()だけでなくインスタンス自体も参照できるようにしたい。
i.unsafed
i.unsigned
i.bit
i.min
i.max
const o = Obs.var({age:Int(12, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
})})
o.age // ここで返すべきはIntインスタンスか、Int.valueOf()で返すプリミティブ値か。
o.age = 24; // ここでセットすべきはIntインスタンスか、Int.valueOf()で返すプリミティブ値か。
// もちろんプリミティブ型で入出力したい。でもObs内部ではInt.valid(value)を呼び出して値チェックする必要がある。
// だからObs内部ではIntインスタンスを保持している必要がある。
// この内部IntインスタンスはProxyインスタンスやsetコールバック関数内からも参照する必要がある。setupコールバック関数の引数では参照する必要はないはずだが、参照できれば便利
// o.someName
// o.setup({})
// o.$.message           // updateコールバック関数で計算し代入された値を参照する
// o._.primitiveSomeName // Intインスタンスなどプリミティブ型のインスタンス参照を返す。代入不可。
// o._isProxy            // Proxyであることを意味する真偽値を返す。
```
```javascript
Obs.Type.Integer(123);
Obs.Type.Int(123);
Obs.Type.I(123);
Obs.T.Int(123);
Obs.T.I(123, {
oo.T.I(123, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
});
```

```javascript
const o = Obs.var({age:0}); // {value:0}を省略した場合。Number型になるべきだが、NaN,+-Infinityは除外したい
```
```javascript
// JavaScriptデフォルトのNumber型はこれで再現できる
Obs.T.N(123, {
  naned: true,
  infinited: true,
})
```
```javascript
const o = Obs.var({age:Obs.T.N(123, {
  naned: true,
  infinited: true,
})};
```

js Numberのようにnewの有無で関数とコンストラクタを実行し分ける方法

new.targetの値をチェックすることで、new演算子の有無を判定し、処理を分けることができる。

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/new.target

```javascript
function CustomNumber(value) {
  // new.target が存在するか（new演算子で呼ばれたか）を判定する
  if (new.target) {
    console.log("コンストラクタとして実行されました");
    this.value = Number(value);
    // new 演算子使用時は自動的に新しいオブジェクトが返される
  } else {
    console.log("関数として実行されました");
    // 関数として実行された場合は、明示的に新しいインスタンスを生成して返す
    return new CustomNumber(value);
  }
}

// コンストラクタとして呼び出す
const obj1 = new CustomNumber(10); // 出力: コンストラクタとして実行されました
console.log(typeof obj1, obj1.value); // object 10

// 関数として呼び出す
const obj2 = CustomNumber(20); // 出力: 関数として実行されました -> コンストラクタとして実行されました
console.log(typeof obj2, obj2.value); // object 20
```

でも`Number`で参照したら関数であり、`v instanceof Number`はできない。

js Numberクラスを継承したクラスのコンストラクタ内でnewの有無により関数とコンストラクタを実行し分ける方法
