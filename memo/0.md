# ObservedProperties

　値を代入したら任意の処理を実行するオブジェクトを生成する。デザインパターンの一つObserverを利用している。モデル駆動とも言う。

* Type		型判定
* Valid		値の妥当性確認（Range,Options）
* Assign	値が代入された時（型や妥当性は不問）
* Change	値が変更された時（型が正しく、値が妥当である。Updateする直前）
* setup		値を一括設定しつつUpdateは一度だけ行う（複数の値を個別に設定するとその数だけUpdateが実行されてしまい負荷が高いから一度だけ行う）
* update	関連する値やHTML要素などを再計算する

```javascript
const o = new Obs({
  name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  age:{type:Number, value:12, valid:Obs.Valid.Range(0, 100)},
  male:{type:Boolean, value:false},
  _:{
    message:{type:String, value:''},
  }},
  (o)=>{
    o._.message = `私の名前は ${o.name}、${o.age} 歳、${o.male ? '男' : '女'}です。`;
  }
);
o.name = 'X';
o.age = 34;
o.male = true;
o.notHas // TypeError: 存在しないプロパティ名です
o.name = 12; // TypeError: 型が違います。
o.setup({name:'Y', age:56}); // 複数のプロパティを好きな分だけ好きなように変更する。更新処理は一度だけ実行される。
```
```javascript
const o = new Obs({...;
class C {}
defineDescriptor(ins, o);
const c = new C();
c.name = 'X';
o.notHas // TypeError: 存在しないプロパティ名です
```
```javascript
const o = new Obs({
  name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  age:{type:Number, value:12, valid:Obs.Valid.Range(0, 100)},
  male:{type:Boolean, value:false},
  name:{type:String, value:'v', valid:Obs.Valid.Option('山田', '鈴木', '田中')}, 
  name:{type:String, value:'v', valid:Obs.Valid.Unique('山田', '鈴木', '田中')}, 
  name:{type:Uint8Array, args:[128]}, 
  name:{value:new Uint8Array(128)}, 
  name: new Uint8Array(128), 
  name: new Obs({
    name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
  }),
```
変数と定数では別のコンストラクタを用意したほうがいいかもしれない。`mutable:true`を全プロパティにセットするの面倒すぎる。
```javascript
const o = new Obs({
  name:{
      type:String, 
      value:'v', 
      nullable:false, undefinedable:false, nanable:false, infinitable:false, mutable:false,
      valid:/[a-z_][0-9a-z_]/i,
  }, 
```
```javascript
const o = new Obs({
  name: '山田',
  age: 12,
  male: false,
  // オブジェクト型はすべて参照に対してのみSetterで型チェック等を行う。オブジェクトが持つ子要素に対しては対象外
  url: new URL('https://www.google.co.jp/'),
  pattern: new RegExp('\n{2,}', 'g'),
  ary: [],
  obj: {}, // 
  sub: new Obs({...}),
});
```

　型は初期値によって推測可能なはず。但し`12`はNumber型であり整数も少数も無限数も非安全な2^53-1より大きい整数も取れてしまう。困る。

　クラス定義でもGetter/Setterに対して同じことをしたい。

```javascript
class MyObsProp extends Obs {
    constructor() {
        super({
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i}, 
        });
    }
}
```

　でもそれだけじゃ思い通りに制御できない。値の参照・代入・型妥当性チェックを自在に呼び出したい。

```javascript
class MyObsProp extends Obs {
    constructor() {
        super({
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
}
```
```javascript
const 変数 = Obs.var({...}); // mutable:true がデフォルト
const 定数 = Obs.fix({...}); // mutable:false がデフォルト
const props = new Obs.Cls({}, {...}, (o, c)=>{}) // 第一引数に任意オブジェクトを渡すと、そのオブジェクトに対してgetter/setterを作る
class MyObsProp extends Obs.Cls { // 第一引数にインスタンス変数thisを渡すと、自動的にgetter/setterを作ってくれる
    constructor() {
        super(this, {
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
    
}
```
```javascript
window.oo = ObservedObject;
window.ooo = ObservedObjectOwner;
```
```javascript
const 変数 = oo.var({...}); // mutable:true がデフォルト
const 定数 = oo.fix({...}); // mutable:false がデフォルト
const props = new oo.Cls({}, {...}, (o, c)=>{}) // 第一引数に任意オブジェクトを渡すと、そのオブジェクトに対してgetter/setterを作る
class MyObsProp extends oo.Cls { // 第一引数にインスタンス変数thisを渡すと、自動的にgetter/setterを作ってくれる
    constructor() {
        super(this, {
            name:{type:String, value:'v', valid:/[a-z_][0-9a-z_]/i, setter:(v)=>{/*this.name に値を代入した直後に実行される処理をここで埋め込み可能*/}}, 
        }, (o)=>{
            // いずれかのプロパティに値が代入されたら必ず実行する処理をここで実装する
            // o.name などで参照・代入できる
        });
    }
    
}
```

* 除外
	* Symbol
	* undefined
* 条件付き許容
	* null
* Boolean
* Number(NaN,±Infinityも含む)
	* Finite
		* Integer(SafeInteger(-2^53-1〜+2^53-1))
		* Float
* BigInt
* Function（AsyncFunction/GeneratorFunction/AysncGeneratorFunction/アロー関数/Asyncアロー関数）
* String
* 欲しいけど無い
	* ID（UUIDv4,v7/ULID）
	* DateTime
		* Date
		* Time
		* TimeSpan
		* DateSpan
		* DateTimeSpan
	* Color（CSS(red, #fff, #ffffff, #ffffffff)）
	* URL
const obs = ObservedValues({
  name: {nullable:false, undefinedable:false, nanable:false, inifitable:false, mutable:false, observable},
});


# プリミティブ型

　JavaScriptは数をNumber型で扱うが、これは64bitメモリであり、かつIEEE754の倍精度浮動小数点数で実装されている。このため十進数表示において、整数は15桁まで、少数は17桁までは正確に表現できるが、それ以上の桁になると正確に表現できず、比較式も不正確な結果を返してしまう。しかもそれを正常とし、エラーを発生させない。

　それでは困る。必ず正確に表せる範囲内のみ扱いたい。しかし実際には`0.000000000000000000001`のように17桁を超えた少数の入力をしてもエラーにできない。もしこれを正確にするなら、`Number.toFixed(15+1)`の文字列比較する。但し、16桁目は四捨五入されるので、16桁目は削除し、正確に表せる15桁までの数で比較する。但し少数比較は等号`===`では誤差があるため比較できない。よって誤差があってもイコールとみなす関数を用意する。

```javascript
nearlyEqual(x, y) {// 等号===の代替。JSのNumber型は64bit浮動少数点数であり比較等号===では完全一致確認できない（console.assert(0.3===0.1+0.2）でエラーになる）これをいくらか解決する。但し15桁の少数まで。
    if (parseInt(x) !== parseInt(y)) {return false}
    const T = parseInt(Math.abs(x + y));
    const tolerance = T < 1 ? Number.EPSILON : Number.EPSILON * T;
    return Math.abs(x - y) < tolerance;
}

// https://qiita.com/murasuke/items/0fb6a6f1bf4c03266720
// 浮動少数で誤差が出ることは避けられない。たとえ桁数を1桁にしても誤差が出てしまう。`(1.15).toFixed(1);`で`1.2`を返して欲しいのに`1.1`を返す等。
// 0.1+0.2=0.30000000000000004(17桁目で狂っている)
// 0.1+0.3=0.4 (なぜかピッタリ)
// 0.1+0.7=0.7999999999999999 (16桁目で途切れている。そもそも0.8未満)
// (0.1+0.7).toFixed(16)=0.7999999999999999 (16桁目で途切れている。そもそも0.8未満)
// (0.1+0.7).toFixed(15)=0.800000000000000 (なぜか15桁にすると0.8になる)
// たぶん桁数は1〜5など少ないほど精度が高まると思われる
// あとはNumber((0.1+0.7).toFixed(15))とすれば数になる。
roundedFloat(v,fig) {return Number(v.toFixed(fig ?? 17))}
roundedFloat(v,fig) {// 少数を16桁までで丸めた値を返す（17桁はIEEE754倍精度少数点数において誤差のない正確な値を示せる最大桁数である。でも0.1+0.2=0.30000000000000004(17桁目で狂っている)になったので16桁までとする）
  const s = v.toFixed(fig ?? 17);
  const S = s.split('.');
  if (1===S.length) {return v}
  const [i,f] = [S[0], S[1].slice(0,-1)]; // 整数部、少数部
  return Number(i+'.'+f);
  const F = 
  S[1]
  const F = 15 < f.length ? f.slice(0, 15) : f;
  // 小数点以下が0000000等ゼロだけで構成される場合や、00010000など途中から末尾までゼロが続く場合は、そのゼロを削除する
}
```

js で正確に浮動小数点数を計算する方法 は次の二通りある。

* 整数に変換してから計算するか
* 専用のライブラリを使用する

```javascript
function roundedFloat(v, fig=0) {
    const D = Math.pow(10, fig);
    const d = Math.trunc(v * D);
    return d / D;
}
```
```javascript
// fig は 少数部分の桁数。JSのNumberは整数15桁,少数17桁まで正確に表せるが、実際少数は様々な場面で誤差を生じさせるため整数化させる必要がある
// つまり少数部は整数化するため15桁が上限になる。しかも元々整数部であった数と共用するため、少数桁を多くするほど整数桁は少なくなる。
// 999999999999999や99999.9999999999や9999999999.99999までしか使えない。
//class RoundedFloat extends Float {
//    constructor(value, unsafed, unsigned, fig, min, max) {
//class DecimalFloat {
//class DecimalFinite {
//class DecimalNumber {
class DecimalFinite {// 10進数における整数と少数を合わせて15桁までの有限数
    constructor(value, fig, unsigned, min, max) {
        super(value, false, unsigned, min, max);
        this._.fig = {i:15-fig整数部の桁数, f:f少数部の桁数}
        this._.pad = {i:{char:'0',fig:'max/min/任意値'}, f:{char:'0',fig:'max/min/任意値'}} // 文字列表現するときの桁数と埋める字
        this._.I = 整数部; Number型としての整数
        this._.F = 少数部;  Number型としての整数
        this._.S = 文字列型としての表現;
        this._.N = Number型としての実数;
        this.roundedFloat(value, fig);
    }
    roundedFloat(v, fig=0) {// v:Number型実数
        const D = Math.pow(10, fig);
        const I = Math.trunc(v);
        const d = Math.trunc(v * D);
        this._.I = I;
        this._.F = parseInt(d.slice(I.toString().length));
        this._.S = `${this._.I}.${this._.F}`; // 整数部, 少数部それぞれに対してのゼロ埋めやスペース埋めをどうするか
        this._.N = parseFloat(this._.S); // d / D
    }
    valueOf() {return this._.N}
    get step() {return Number(Math.pow(0.1, this._.fig).toFixed(this._.fig));}
    // 四則演算(+:add, -:sub, *:mul, /:div), %:sur, **:pow        剰余:surplus
    add(v){}
    sub(v){}
    mul(v){}
    div(v){}
    sur(v){}
    pow(v){}
    // 自身の値と引数を演算した結果の新しいDecimalFloatインスタンスを返す（自身のインスタンス値はそのまま変更せず）
    toAdd(v) {}
    toSub(v) {}
    toMul(v) {}
    toDiv(v) {}
    toSur(v) {}
    toPow(v) {}
    // 演算した結果を引数にセットする（自身のインスタンス値はそのまま変更せず）引数がプリミティブ型かDecimalFloat型であるべきだし、それによって誤差が生じうる。
    addTo(){}
    subTo(){}
    mulTo(){}
    divTo(){}
    surTo(){}
    powTo(){}
}
class FazzyFloat {}// JavaScript標準のNumber型で、かつNaN,Infinityを除外した数
```

```
十進数15桁で整数のみなら最大1000兆-1。
999999999999999
999,999,999,999,999 K,M,G,T,E
999兆9999億9999万9999

2^32 = 4294967296 42億
2^49 = 562949950000000(5.6294995e+14) 562兆
十進数15桁はこの間
       999999999999999
2^49までなら表現できる。但し少数が0桁の場合。
十進数15桁はこの間
2^50 = 1125899900000000(1.1258999e+15) 1125兆
2^64 = 18446744000000000000(1.8446744e+19)
```
```
十進数整数12桁少数3桁計15桁で整数のみなら最大1兆-1。
-999999999999.999〜+999999999999.999
```

　やはり元となるNumber型で`0.1+0.7`すると`7.99999`になってしまうのが問題だ。これを根本解決することはできない。よって少数でなく整数を基本とすべきか。

　型を省略してNumber型がセットされた時、かつNumber.isSafeInteger()が真なら、今後もSafedIntegerを基本としたい。

```javascript
const o = new Obs({age:0});
```

　誤差が生じることを承知の上で浮動小数点数を使いたい時は以下のようにする。

```javascript
const o = new Obs({weight:{value:Float(62.1)}}); // Float
const o = new Obs({weight:{value:Float(62.0)}}); // Float
const o = new Obs({weight:{value:Float(62)}});   // Float
const o = new Obs({weight:{value:62.1}});        // Float判定
const o = new Obs({weight:{value:62.0}});        // Int判定
const o = new Obs({weight:{value:62}});          // Int判定
```

　型指定を省略するとInt判定されてしまう場合があるため区別できず危険。

```javascript
const o = new Obs({weight:{value:62.1}});        // Float判定にすべき？　それとも例外発生または警告ログ出力させるべき？
const o = new Obs({weight:{value:62.0}});        // Int判定
const o = new Obs({weight:{value:62}});          // Int判定
```




　Number型を派生させ、Float, Intの二つのプリミティブ型を作りたい。

* Float: Number型だが、`NaN`,`Infinity`,`-Infinity`は代入できない(有限数Finite)
* Int: Number型だが、`Number.isSafeInteger()`な値しか代入できない
    * AllInt: FasyInt/Intの両方を生成できる`new AllInt(value, unsafed, unsigned, bit, min, max)`
    * FussyInt: unsafed=trueな整数のみ生成できる`new FasyInt(value, unsigned, bit, min, max)`
    * Int: unsafed=falseな整数のみ生成できる`new Int(value, unsigned, bit, min, max)`
        * Odd: 奇数のみ生成できる
        * Even: 偶数のみ生成できる
        * Pow: xのy乗のみ生成できる`new Pow(2)` 2の0〜n(正数)乗のみセット可能
        * これら数列はValidatorで行うべきか。個別の型にしていたらキリがない。固定値でなく固定式でもなく任意式で自由に実装できるようにすべき。

```javascript
Number
    Float
        Rate        0〜1
        Percent     0〜100
        Fraction    1/2, -2/9 (1/0 ゼロ除算不能。整数のみ代入可)
    Int             -2^53-1〜+2^53-1迄(2^52. 1〜52bitの符号付き迄)
    Ratio           1:1.414 (3:2:1等3つ以上にも対応したい。各値はNumber/Float/Int型のいずれか) でもこれプリミティブ型とは違う？　対象外にすべきか。
```
```javascript
Obs.Type.Int(123);
Int(123);
```
```javascript
const i = new Obs.Type.Int(123);
const i = new Int(123);
i.valueOf(); // プリミティブ値を返却する

const i = new Int(123, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
});
// 以下のようにインスタンスから参照したい要素もあるため、valueOf()だけでなくインスタンス自体も参照できるようにしたい。
i.unsafed
i.unsigned
i.bit
i.min
i.max
const o = Obs.var({age:Int(12, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
})})
o.age // ここで返すべきはIntインスタンスか、Int.valueOf()で返すプリミティブ値か。
o.age = 24; // ここでセットすべきはIntインスタンスか、Int.valueOf()で返すプリミティブ値か。
// もちろんプリミティブ型で入出力したい。でもObs内部ではInt.valid(value)を呼び出して値チェックする必要がある。
// だからObs内部ではIntインスタンスを保持している必要がある。
// この内部IntインスタンスはProxyインスタンスやsetコールバック関数内からも参照する必要がある。setupコールバック関数の引数では参照する必要はないはずだが、参照できれば便利
// o.someName
// o.setup({})
// o.$.message           // updateコールバック関数で計算し代入された値を参照する
// o._.primitiveSomeName // Intインスタンスなどプリミティブ型のインスタンス参照を返す。代入不可。
// o._isProxy            // Proxyであることを意味する真偽値を返す。
```
```javascript
Obs.Type.Integer(123);
Obs.Type.Int(123);
Obs.Type.I(123);
Obs.T.Int(123);
Obs.T.I(123, {
oo.T.I(123, {
  unsafed: false,
  unsigned: false,
  bit: 32,
  min: 0,
  max: 100
});
```

```javascript
const o = Obs.var({age:0}); // {value:0}を省略した場合。Number型になるべきだが、NaN,+-Infinityは除外したい
```
```javascript
// JavaScriptデフォルトのNumber型はこれで再現できる
Obs.T.N(123, {
  naned: true,
  infinited: true,
})
```
```javascript
const o = Obs.var({age:Obs.T.N(123, {
  naned: true,
  infinited: true,
})};
```

js Numberのようにnewの有無で関数とコンストラクタを実行し分ける方法

new.targetの値をチェックすることで、new演算子の有無を判定し、処理を分けることができる。

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/new.target

```javascript
function CustomNumber(value) {
  // new.target が存在するか（new演算子で呼ばれたか）を判定する
  if (new.target) {
    console.log("コンストラクタとして実行されました");
    this.value = Number(value);
    // new 演算子使用時は自動的に新しいオブジェクトが返される
  } else {
    console.log("関数として実行されました");
    // 関数として実行された場合は、明示的に新しいインスタンスを生成して返す
    return new CustomNumber(value);
  }
}

// コンストラクタとして呼び出す
const obj1 = new CustomNumber(10); // 出力: コンストラクタとして実行されました
console.log(typeof obj1, obj1.value); // object 10

// 関数として呼び出す
const obj2 = CustomNumber(20); // 出力: 関数として実行されました -> コンストラクタとして実行されました
console.log(typeof obj2, obj2.value); // object 20
```

でも`Number`で参照したら関数であり、`v instanceof Number`はできない。

js Numberクラスを継承したクラスのコンストラクタ内でnewの有無により関数とコンストラクタを実行し分ける方法






# Proxy

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Proxy#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E5%86%85%E9%83%A8%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89

```javascript
const o = oo.var({name:'', age:0, male:false, weight:oo.float(62.1)});
const f = oo.fix({PI:oo.float(3.14)});

console.assert(o instanceof oo.ObservedObject); // falseになってしまうかも？
console.assert(o instanceof oo.FixedObject); // falseになってしまうかも？

o.name = '山田';
o.age = 12;

o({name:'鈴木', age:24}); // 任意プロパティを一括変更し、一度だけ更新処理する。

const p = new o(); // Cloneする

console.assert(p.has('name'));
console.assert(p.has('age'));
console.assert('鈴木'===p.name)
console.assert(24===p.age)
```

```javascript
const a = new Proxy({},{});
```

# 型

　実数を意味する英語 Finite(有限数) Float(浮動小数点数(2進数)) Real(実数)

　JSのNumber型は浮動小数点数なのでFloatが相応しい。倍精度浮動小数点数なので、他言語ならDouble型である。

* 既存Primitive制限系
    * Quantity      Number型を自由に制約する型（NaN,無限数,非安全範囲数,符号無し,最小値,最大値）
        * Float     Number型のうち実数のみ（NaN,無限数を除外） Number.EPSILONを考慮してイコール比較するメソッドを追加する。同じく閾値min,maxにピッタリ値セットする。
            * FixedFloat  Float型のうち指定桁数までは整数化して誤差を文字列化して誤差がないように見せる（(0.1+0.7)=0.799999だが、これを0.7*10して7.999にしtoFixed()して文字列としては正確な十進数表示を返す。但し内部では相変わらずIEEE754仕様値のため0.799999である。valueOf()ではNumber型を返すので誤差るからnearlyEqual()で比較すること。）
            * Rate      Float型のうち0〜1の実数のみ
            * Percent   Float型のうち0〜100の実数のみ
        * Integer   Number型のうち安全な整数のみ
            * Random32  Integer型のうち参照する度に異なる乱数値へと自身の値が変化する。参照のみ可能で代入不可。53bit迄なので疑似乱数方式では32bit迄。64bit以降は不可
                * Dice      Random型のうち1〜6など所定の範囲内であるもの。参照のみ可能で代入不可
            * Sequence  Integer型のうち参照する度に必ず指定の変化をする（+1/-1等。端に到達したとき対極へ行くか逆方向に戻るか全要素を使い果たしたと見做し例外発生か）
            * Unique    Integer型のうち一意であることを完全保証する（システム全体における値を管理する）。参照のみ可能で代入不可
                * UniqueSequence    Sequenceを用いてUniqueである数を作り続ける。同じ数は絶対使わない。代入不可。
    * MultiNumberRandom 複数のNumber型を内部に保持した型乱数。64,128,256,512,1024,〜bit
    * BigRandom         BigInt型乱数。64bit〜
    * UUID              BigIntかUint8Array型のうち乱数により作成した128bit値。重複する確率は無視できるほど小さい。Base16表現+ハイフン4字=36字
    * ULID              BigIntかUint8Array型のうち乱数により作成した128bit値。重複する確率は無視できるほど小さい。Base32表現=26字
* 新規Object系
    * NumberDecimal     (Decimalを10に略すとNumber10でn10になるが、Integer8bitを略すとi8になる。両者の数字は前者が基数で後者がbit数であり異なる。基数B,桁数Fで指定希望)
    * DecimalNumber     整数部と少数部をそれぞれNumber型で管理する。プリミティブ(Number)型との互換性はない
    * DecimalFlaot      Float型だが10進数の指定桁数迄の数。プリミティブ(Number)型との互換性はない
    * DecimalReal       プリミティブ(Number)型との互換性はない
    * DecimalInteger    Integer型だが10進数の指定桁数迄の数。
    * DecimalString     String型だが


数の引数は次の要素が欲しい。

* 代入可能か(Assignable)
    * Undefindable      undefinedを代入可能か
    * Nullable          nullを代入可能か
    * Nanable           NaNを代入可能か
    * Infinitable       無限数を代入可能か
    * Mutable           任意値を再代入可能か
* 量(quantity, amout)
    * Unsignable
    * 冪乗Power（底,指数 2^3 底(base)=2,指数(exponent)=3）
        * Base: 2,8,10,12,16,24,32,36,64,85,128,256
        * Exponent: 1〜N
* 範囲(range)
    * Unsafable
    * Range
        * min: 最小値
        * max: 最大値


* 変数代入可能性: VarAssignable
* 数量: NumberVolume
* 数範囲: NumberRange

* 残余引数／可変長引数
    * 柔軟引数(FlexArgument)
        * 任意の定めた名前と型のプロパティを持つ
        * なるだけ少ない引数で思い通りに作れるようデフォルト値が工夫されている

```javascript
class VarAssignable {// 変数への代入可能性。型を定義するのに用いる。
    static #MEMBERS = 'undefindable nullable nanable infinitable mutable'.split(' ');
    static get MEMBERS() {return this.#MEMBERS}
    static get #OPTIONS = this.MEMBERS.reduce((o,k)=>o[k]=false);
    static isMember(name) {return this.MEMBER.some(n=>n===name)}
    constructor(options) {
        this.#initOptions(options);
    }
    /*
    get #defaultOptions() { return {
        undefindable: false,   // undefinedを代入可能か
        nullable: false,       // nullを代入可能か
        nanable: false,        // NaNを代入可能か
        infinitable: false,    // 無限数を代入可能か
        mutable: false,        // 任意値を再代入可能か
    } }
    */
    #initOptions(options) {
//        const D = this.#defaultOptions;
        const D = VarAssignable.#OPTIONS;
        for (let k of Object.keys(options)) {if (!VarAssignable.isMember(k)) {console.warn(`不正なメンバのため削除しました。:${k}`); delete options[k];}}
        this._ = {...D, ...options};
        //for (let k of Object.keys(options)) {if (!VarAssignable.isMember(k)) {throw new TypeError(`不正なメンバです。:${k}`)}}
    }
}
```
```javascript
class NumberVolume {// 数量の定義。型を定義するのに用いる。
    static #MEMBERS = 'undefindable nullable nanable infinitable mutable'.split(' ');
    static get MEMBERS() {return this.#MEMBERS}
    static get #OPTIONS() {return this.MEMBERS.reduce((o,k)=>o[k]=false)};
    static isMember(name) {return this.MEMBER.some(n=>n===name)}
    constructor(options) {
        this.#initOptions(options);
    }
    #initOptions(options) {
        const D = VarAssignable.#OPTIONS;
        for (let k of Object.keys(options)) {if (!VarAssignable.isMember(k)) {console.warn(`不正なメンバのため削除しました。:${k}`); delete options[k];}}
        this._ = {...D, ...options};
    }
}
```




```javascript
class NamedObject {// PythonのNamedTupleのようなもの。

}

const varAssignable = new NamedObject('undefindable nullable nanable infinitable mutable');
```
```javascript
class TypedObject {// C#のEnumのようなもの。但しメンバは別個の型を持てる。独自のキーバリューを持ちそれぞれが所定の型をもち自身も独自の型をもつ。つまり動的クラス生成。

}
const VarAssignable = new TypedObject({
    undefindable: false,
    nullable: false,
    nanable: false,
    infinitable: false,
    mutable: false});
const NumberVolume = new TypedObject({
    unsafable: false, // 何も引数がなければunsafable=trueと判定することで省略可能か？
    unsignable: false,
    base: Integer({value:2, min:2, max:Number.SAFE_MAX_INTEGER, nullable:true}),
    exponent: Integer({value:32, min:1, max:Number.SAFE_MAX_INTEGER, nullable:true}),
});
const NumberRange = new TypedObject({
    min: Integer({value:0, min:Number.SAFE_MIN_INTEGER, max:Number.SAFE_MAX_INTEGER}),
    max: Integer({value:0, min:Number.SAFE_MIN_INTEGER, max:Number.SAFE_MAX_INTEGER}),
});


const assignable = new VarAssignable({mutable:true});
const = new NumberVolume(); // {unsafable:true, unsignable:false, base:2, exp:32}
const = new NumberVolume(false); // {unsafable:false, unsignable:false, base:2, exp:32}
const = new NumberVolume(true); // {unsafable:false, unsignable:true, base:2, exp:32}
const = new NumberVolume(true,10,4); // {unsafable:false, unsignable:true, base:10, exp:4}
const = new ({});
```

# 型の引数を最適化する

* なるだけ引数を減らしても思い通りに作れるようにする
* なるだけ引数の順序は覚えずに済むようにする
* なるだけ引数の名前は覚えることが少ないようにする（統一性をもたせる）

```javascript
const o = oo.var(`
    age ui8 [3,8] 3;
    name str [8,32] /[a-z]{8,32}/i ''
`);
const o = oo.var({
    name: '',
    name: String,
    name: String(),
    name: String(''),
    name: new String,
    name: new String(),
    name: { // 内部でoo.var({})する
        first: '',
        last: '',
    },
    age: 0,
    age: Integer,
    age: Integer(),
    age: new Integer,
    age: new Integer(),
    age: oo.C.Integer,
    age: oo.T.i,
    age: oo.T.int,
    age: oo.T.integer,
    age: oo.T.i(123),                           // 第一引数にvalue
    age: oo.T.i({value:123}),                   // 第一引数に任意プロパティを順序不問でセット
    age: oo.T.i(123, {unsigned:true, bit:32, min:3, max:8}),    // 第一引数にvalue, 第二引数に任意プロパティを順序不問でセット
    age: oo.T.i(123, {unsigned:true, bit:32, range:[3,8]}),
    age: oo.T.i(123, unsigned:true, bit:32, min:3, max:8),      // 第一、第二にオブジェクトを使わない引数を、任意の数だけ
    age: oo.T.i(123, unsigned:true, bit:32, range:[3,8]),
    age: 'ui8',

    age: oo.DecimalFloat(), // fig:1, value:0, part:{i:0, f:0}
    age: oo.DecimalFloat(2), // fig:2, value:0, part:{i:0, f:0}
    age: oo.DecimalFloat([0,0,2]), // fig:2, value:0, part:{i:0, f:0}
    age: oo.DecimalFloat([123,45,6]), // fig:6, value:0, part:{i:123, f:45}
    age: oo.DecimalFloat([123,45,6], {}), // fig:6, value:0, part:{i:123, f:45}
    age: oo.DecimalInteger(), // value:0
});
```


js Number型のように'Number'で関数とクラスを参照する方法（Number()、new Number()、instanceofの右辺になる、の三つを満たす方法）

AI による概要
JavaScriptにおいて、
Number型と同様に単一の識別子（例えばMyType）で「関数呼び出し (MyType())」「コンストラクタ呼び出し (new MyType())」「instanceofの右辺」の3つを満たす方法は、コンストラクタ関数と、そのコンストラクタのプロトタイプを継承するクラスを同じ識別子に割り当てることで実現できます。 
具体的な方法は以下の通りです。
実現方法
JavaScriptでは、関数もオブジェクトであり、コンストラクタとして機能させることができます。また、instanceof演算子は、右辺に指定されたコンストラクタのプロトタイプチェーンに、左辺のオブジェクトが含まれているかどうかをチェックします。 
この性質を利用して、以下のように実装します。
javascript

// 1. MyTypeという名前のコンストラクタ関数を定義します。
function MyType(value) {
    // new演算子がついているかどうかで処理を分岐させます。
    if (new.target) {
        // new MyType() の場合: インスタンスを初期化します。
        this.value = value;
    } else {
        // MyType() の場合: 新しいインスタンスを生成して返します (Number()の振る舞い)。
        return new MyType(value);
    }
}

// 2. instanceof のチェックのために、プロトタイプにメソッドなどを追加できます。
MyType.prototype.getValue = function() {
    return this.value;
};

// 3. 静的メソッドを追加することも可能です (Number.parseInt()のような振る舞い)。
MyType.staticMethod = function() {
    console.log("This is a static method.");
};

// 4. クラスの別名として同じ識別子に代入します (実際には必要ありませんが、概念として)。
// MyType はすでにコンストラクタ関数なので、そのまま使えます。

使用例
上記のMyTypeを使用すると、要求された3つの条件を満たせます。
javascript

// 1. 関数呼び出し (MyType())
// プリミティブ値ではなく、MyTypeのインスタンスを返します。
const val = MyType(10); 
console.log(typeof val); // "object"
console.log(val.getValue()); // 10

// 2. コンストラクタ呼び出し (new MyType())
const instance = new MyType(20);
console.log(typeof instance); // "object"
console.log(instance.getValue()); // 20

// 3. instanceofの右辺になる
console.log(val instanceof MyType); // true
console.log(instance instanceof MyType); // true

// 静的メソッドの呼び出し
MyType.staticMethod(); // "This is a static method."

このように、単一の関数オブジェクトがコンストラクタとしても通常の関数としても機能し、instanceof演算子の対象としても認識されます。
